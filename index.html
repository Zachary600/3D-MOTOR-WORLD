<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>3D Bike Racing Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body class="text-white">

<!-- Loading Screen -->
<div id="loadingScreen" class="fixed inset-0 flex flex-col items-center justify-center bg-black z-50">
    <div class="text-xl mb-4">Loading Assets...</div>
    <div class="w-64 h-2 bg-gray-700 rounded">
        <div id="loadingBar" class="h-2 bg-green-500 w-0 rounded"></div>
    </div>
</div>

<!-- Start Menu -->
<div id="startMenu" class="fixed inset-0 hidden flex items-center justify-center bg-black/80 z-40">
    <div class="bg-gray-900 p-6 rounded-xl text-center space-y-4 w-72">
        <h1 class="text-2xl font-bold">üèç Bike Racer 3D</h1>
        <select id="difficulty" class="w-full text-black p-2 rounded">
            <option value="1">Easy</option>
            <option value="1.2">Medium</option>
            <option value="1.5">Hard</option>
        </select>
        <button id="startBtn" class="w-full bg-green-600 py-2 rounded hover:bg-green-700">Start Race</button>
    </div>
</div>

<!-- HUD -->
<div id="hud" class="fixed top-0 left-0 right-0 p-3 flex justify-between items-center text-sm bg-black/40 hidden z-30">
    <div>Speed: <span id="speed">0</span></div>
    <div>Position: <span id="position">1 / 2</span></div>
    <button id="restartBtn" class="bg-red-600 px-3 py-1 rounded">Restart</button>
</div>

<!-- Touch Controls -->
<div class="fixed bottom-6 left-6 flex space-x-4 z-30 md:hidden">
    <button id="leftBtn" class="bg-black/60 p-4 rounded-full"><i class="fa-solid fa-arrow-left"></i></button>
    <button id="rightBtn" class="bg-black/60 p-4 rounded-full"><i class="fa-solid fa-arrow-right"></i></button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';

let scene, camera, renderer, clock;
let player, aiBike;
let speed = 0;
let aiSpeed = 0.18;
let lane = 0;
let difficultyMultiplier = 1;
let running = false;

const obstacles = [];
const keys = {};

/* DOM refs (must be queried in module scope) */
const loadingScreen = document.getElementById('loadingScreen');
const loadingBar = document.getElementById('loadingBar');
const startMenu = document.getElementById('startMenu');
const hud = document.getElementById('hud');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const difficulty = document.getElementById('difficulty');
const speedEl = document.getElementById('speed');
const posEl = document.getElementById('position');

init();
animate();

function init() {
    clock = new THREE.Clock();

    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 10, 80);

    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 4, 8);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(5, 10, 5);
    scene.add(dir);

    const road = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 500),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    road.rotation.x = -Math.PI / 2;
    road.position.z = -200;
    scene.add(road);

    for (let i = 0; i < 40; i++) {
        const h = Math.random() * 6 + 2;
        const b = new THREE.Mesh(
            new THREE.BoxGeometry(2, h, 2),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        b.position.set(Math.random() > 0.5 ? 6 : -6, h / 2, -i * 12);
        scene.add(b);
    }

    for (let i = 0; i < 20; i++) {
        const o = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0xff3333 })
        );
        o.position.set((Math.random() - 0.5) * 4, 0.5, -i * 20 - 30);
        scene.add(o);
        obstacles.push(o);
    }

    loadBikeModels();

    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    leftBtn.onclick = () => lane = Math.max(-1, lane - 1);
    rightBtn.onclick = () => lane = Math.min(1, lane + 1);

    startBtn.onclick = startGame;
    restartBtn.onclick = () => location.reload();
}

function loadBikeModels() {
    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(draco);

    let loaded = 0;
    const updateBar = () => {
        loaded++;
        loadingBar.style.width = (loaded / 2) * 100 + '%';
        if (loaded === 2) loadingScreen.classList.add('hidden');
    };

    loader.load(
        'bike.glb',
        gltf => {
            player = gltf.scene;
            player.scale.set(0.8, 0.8, 0.8);
            player.position.y = 0.5;
            scene.add(player);
            updateBar();
        },
        undefined,
        () => {
            player = fallbackBike(0x00ff00);
            player.position.y = 0.5;
            scene.add(player);
            updateBar();
        }
    );

    loader.load(
        'bike.glb',
        gltf => {
            aiBike = gltf.scene;
            aiBike.scale.set(0.8, 0.8, 0.8);
            aiBike.position.set(1.5, 0.5, 0);
            scene.add(aiBike);
            updateBar();
        },
        undefined,
        () => {
            aiBike = fallbackBike(0xff0000);
            aiBike.position.set(1.5, 0.5, 0);
            scene.add(aiBike);
            updateBar();
        }
    );
}

function fallbackBike(color) {
    return new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.5, 1.5),
        new THREE.MeshStandardMaterial({ color })
    );
}

function startGame() {
    difficultyMultiplier = parseFloat(difficulty.value);
    startMenu.classList.add('hidden');
    hud.classList.remove('hidden');
    running = true;
}

function animate() {
    requestAnimationFrame(animate);
    if (!running || !player) return;

    const dt = clock.getDelta();

    if (keys['ArrowLeft']) lane = Math.max(-1, lane - 0.05);
    if (keys['ArrowRight']) lane = Math.min(1, lane + 0.05);
    if (keys['ArrowUp']) speed = Math.min(speed + 0.01, 0.4);
    else speed *= 0.98;

    player.position.x = THREE.MathUtils.lerp(player.position.x, lane * 1.5, 0.1);
    player.position.z -= speed;

    if (aiBike) {
        aiSpeed += (speed - aiSpeed) * 0.02 * difficultyMultiplier;
        aiBike.position.z -= aiSpeed;
        aiBike.position.x = Math.sin(clock.elapsedTime) * 1.2;
    }

    camera.position.z = player.position.z + 8;
    camera.lookAt(player.position);

    obstacles.forEach(o => {
        if (o.position.distanceTo(player.position) < 0.8) {
            speed *= 0.3;
            spawnCrash(player.position);
        }
    });

    speedEl.textContent = (speed * 100).toFixed(0);
    if (aiBike) posEl.textContent = player.position.z < aiBike.position.z ? '1 / 2' : '2 / 2';

    renderer.render(scene, camera);
}

function spawnCrash(pos) {
    const p = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 6, 6),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    p.position.copy(pos);
    scene.add(p);
    setTimeout(() => scene.remove(p), 300);
}

function onResize() {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
}
</script>
</body>
</html>